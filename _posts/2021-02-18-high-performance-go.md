
阅读学习 DC 的讲座的笔记。
* [讲座博客](https://dave.cheney.net/high-performance-go)
* [代码库](https://github.com/davecheney/high-performance-go-workshop)
* [中文翻译](https://blog.zeromake.com/pages/high-performance-go-workshop)：疑似机器翻译，选择性地对照着看

## benchmark

一些有用的flag：
* -benchtime=10s 表示运行基准测试至少10s时间
* -benchtime=20x 表示基准测试运行时，循环20次，即b.N=20
* -count=10 表示重复运行10次基准测试

使用benchstat工具来对多次基准测试的结果进行统计和比较，这有助于减少电源管理，后台进程，散热等因素对测试结果带来的影响，

如果基准测试函数中需要包含一些不想被纳入测试计时的代码，可以用 b.ResetTimer（用在循环体外）或者 b.StopTimer/b.StartTimer（用在循环体内）来规避。

测试内存分配情况，有两种方法：
（1）在测试函数体里添加：b.ReportAllocs()
（2）使用 go test -benchmem 执行测试

注意：编译器的内联优化可能导致某些基准测试失效。

profiling benchmark:
支持在运行基准测试时生成CPU，memory，block的profile：
* -cpuprofile=$FILE
* -memprofile=$FILE, -memprofilerate=N 设置profile rate为1/N
* -blockprofile=$FILE
使用以上三个flag中的任意一个都会产生测试二进制文件 xxx.test。
生成的profile文件可以用pprof来分析。

问题：blockprofile是啥？profile rate 是啥？


## 编译优化

Go的编译器分为前端和后端。逃逸分析、内联属于前端处理，此时代码仍处在 AST 形式。后端是SSA编译器，在这一块做的优化包括对 dead code，bounds check，nil check的消除。

### 逃逸分析（Escape Analysis）

goroutine的栈用来存储局部变量。对于栈上的变量不需要做垃圾收集（GC），因为它们会在函数返回时自动被收集。所以在栈上分配内存可以提高程序效率。
在C/C++中，需要程序员自己决定选择在堆还是在栈上分配内存，如果选择有误会带来内存方面的bug。
在Go中，这部分工作由编译器完成的。如果一个值的寿命超出了函数调用的生命周期，那么编译器会自动将该值移动到堆中，这叫做**逃逸**到堆。
```go
type Foo struct {
	a, b, c, d int
}

func NewFoo() *Foo {
	return &Foo{a: 3, b: 1, c: 4, d: 7}
}
```
这段程序中，`NewFoo`函数中分配的`Foo`变量就会逃逸到堆中，因为它是作为函数的返回值，在函数调用结束后还可能会被用到。

但是编译器也可以反过来做：将本该分配在堆上的变量移动到栈上。例如：
```go
func Sum() int {
	const count = 100
	numbers := make([]int, count)
	for i := range numbers {
		numbers[i] = i + 1
	}

	var sum int
	for _, i := range numbers {
		sum += i
	}
	return sum
}

func main() {
	answer := Sum()
	fmt.Println(answer)
}
```
这段程序中，编译器会把`numbers`切片存储在栈上，因为这个变量只在`Sum`函数中被使用。这样就免去了对`numbers`变量的GC了。

口说无凭，我们可以证明这一点：使用 `-m` 打印逃逸分析结果。
`-m`表示 `print optimization decisions`。更多flag可以通过`go tool compile -h`查看。
```shell
go build -gcflags="-m" sum.go
# command-line-arguments
./sum.go:25:13: inlining call to fmt.Println
./sum.go:10:17: make([]int, count) does not escape
./sum.go:25:17: Sum() escapes to heap
./sum.go:25:13: []interface {} literal does not escape
<autogenerated>:1: .this does not escape
```
从中可看出`numbers`切片没有逃逸。


练习：
（1）Does this optimisation hold true for all values of `count`?
不是，当count较大，比如为10000时，切片会逃逸到堆上。我推测这是因为栈的空间有限，不能容纳很大的变量。

（2）Does this optimisation hold true if `count` is a variable, not a constant?
不是，把`const count = 100`改成`var count = 100`，其他代码不变，发现切片会逃逸到堆上。我推测这是因为`count`是变量时，编译器无法确定其大小，保险起见就把切片分配到堆上。

（3）Does this optimisation hold true if `count` is a parameter to `Sum`?
不是，当`count`是`Sum`函数的参数时，切片会逃逸到堆上。 推测原因同（2），编译器无法确定切片大小。

通过基准测试可做进一步验证：
```go
var result int

func BenchmarkSum(b *testing.B) {
	b.ReportAllocs()
	var r int
	for i := 0; i < b.N; i++ {
		r = Sum()
	}
	result = r
}
```
当`count`是常量时，测试结果表明没有堆内存分配：
```
goos: darwin
goarch: amd64
BenchmarkSum-12    	12470510	        88.1 ns/op	       0 B/op	       0 allocs/op
```
当`count`是变量时，测试结果表明有堆内存分配：
```
goos: darwin
goarch: amd64
BenchmarkSum-12    	 6184479	       182 ns/op	     896 B/op	       1 allocs/op
```



### 内联（Inlining）
在Go中函数调用是有开销（overhead）的。内联是一种避免这些开销的经典优化方法。
在Go 1.11 之前，内联只作用于**叶子函数（leaf function）**上。叶子函数是指不会调用其他函数的函数。这么做的原因是：
* 如果是做了很多事情的“大”函数，那么它的前导开销可以忽略不计
* 而对于小函数来说，开销相对于它所做的工作是比较大的。对其使用内联，收益大些

#### 举例
```go
package main

// START OMIT
func Max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func F() {
	const a, b = 100, 20
	if Max(a, b) == b {
		panic(b)
	}
}

// END OMIT

func main() {
	F()
}
```
如前文一般，使用`-gcflags=-m`来查看编译器的优化动作：
```shell
$ go build -gcflags="-m" max.go
# command-line-arguments
./max.go:4:6: can inline Max
./max.go:11:6: can inline F
./max.go:13:8: inlining call to Max
./max.go:20:6: can inline main
./max.go:21:3: inlining call to F
./max.go:21:3: inlining call to Max
```
可见，函数F和Max都被内联处理了。

#### 内联长啥样
查看函数F():
```shell
$ go build -gcflags="-S" max.go  2>&1 | grep -A5 '"".F STEXT'
"".F STEXT nosplit size=1 args=0x0 locals=0x0
	0x0000 00000 (/Users/chenluxin/Codes/go/high-performance-go-workshop/03-compiler-optimisations/examples/max/max.go:11)	TEXT	"".F(SB), NOSPLIT|ABIInternal, $0-0
	0x0000 00000 (/Users/chenluxin/Codes/go/high-performance-go-workshop/03-compiler-optimisations/examples/max/max.go:11)	FUNCDATA	$0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
	0x0000 00000 (/Users/chenluxin/Codes/go/high-performance-go-workshop/03-compiler-optimisations/examples/max/max.go:11)	FUNCDATA	$1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
	0x0000 00000 (/Users/chenluxin/Codes/go/high-performance-go-workshop/03-compiler-optimisations/examples/max/max.go:13)	RET
	0x0000 c3                                               .
```
忽略FUNCDATA和PCDATA，可见函数F()最终变成了：
```go
func F() {
        return
}
```

#### 讨论
如果在函数F()中，把a和b声明为变量而非常量，或者a和b被当做参数传递给F()，结果会有变化吗？
实验结果是，两种情况下，Max和F函数都会被内联处理。但是在第二种情况中，打印出的汇编语句不一样了：
```
"".F STEXT size=103 args=0x10 locals=0x18
	0x0000 00000 (/Users/chenluxin/Codes/go/high-performance-go-workshop/03-compiler-optimisations/examples/max/max.go:11)	TEXT	"".F(SB), ABIInternal, $24-16
	0x0000 00000 (/Users/chenluxin/Codes/go/high-performance-go-workshop/03-compiler-optimisations/examples/max/max.go:11)	MOVQ	(TLS), CX
	0x0009 00009 (/Users/chenluxin/Codes/go/high-performance-go-workshop/03-compiler-optimisations/examples/max/max.go:11)	CMPQ	SP, 16(CX)
	0x000d 00013 (/Users/chenluxin/Codes/go/high-performance-go-workshop/03-compiler-optimisations/examples/max/max.go:11)	PCDATA	$0, $-2
	0x000d 00013 (/Users/chenluxin/Codes/go/high-performance-go-workshop/03-compiler-optimisations/examples/max/max.go:11)	JLS	96
```

#### 调整内联级别
通过`-gcflags=-l`来调整内联级别。
* `-gcflags=-l`, 禁用内联
* `-gcflags='-l -l'` 内联级别 2，更激进，可能更快，可能会生成更大的二进制文件
* `-gcflags='-l -l -l'` 内联 3 级，更加激进，二进制文件肯定更大，也许会更快，但也可能带来问题
* `-gcflags=-l=4` 将启用实验性的**中栈内联**（mid stack inlining optimisation）

从Go 1.12 开始，默认开启上述的中栈内联。在上个例子中，F()函数严格意义上来说并不是叶子函数，却也被内联了。这是因为，当Max函数内联到F后，F函数中没有其他函数调用，也变成了叶子函数。

### 消除无效代码（Dead code elimination）
在前一个例子中，为什么要强调a和b是常量呢？因为这种情况下，编译器就能通过内联和一系列**分支消除（branch elimination）**操作，将F函数最终变为：
```go
func F() {
}
```
消除无效代码是指一类优化方法，分支消除是其中之一。这里**无效（dead）**的含义是指永远不会被执行到，因此这些代码不必编译，也不会包含在最终的二进制文件中。

一个利用分支消除的例子：
声明一个debug布尔常量：`const debug = false`，再将debug有关的逻辑放在条件语句块中，只有debug为true时才会执行。这样，当debug为false时，这些代码不会被编译到二进制文件中。


