
阅读学习 DC 的讲座的笔记。
* [讲座博客](https://dave.cheney.net/high-performance-go)
* [代码库](https://github.com/davecheney/high-performance-go-workshop)
* [中文翻译](https://blog.zeromake.com/pages/high-performance-go-workshop)：疑似机器翻译，选择性地对照着看

## benchmark

一些有用的flag：
* -benchtime=10s 表示运行基准测试至少10s时间
* -benchtime=20x 表示基准测试运行时，循环20次，即b.N=20
* -count=10 表示重复运行10次基准测试

使用benchstat工具来对多次基准测试的结果进行统计和比较，这有助于减少电源管理，后台进程，散热等因素对测试结果带来的影响，

如果基准测试函数中需要包含一些不想被纳入测试计时的代码，可以用 b.ResetTimer（用在循环体外）或者 b.StopTimer/b.StartTimer（用在循环体内）来规避。

测试内存分配情况，有两种方法：
（1）在测试函数体里添加：b.ReportAllocs()
（2）使用 go test -benchmem 执行测试

注意：编译器的内联优化可能导致某些基准测试失效。

profiling benchmark:
支持在运行基准测试时生成CPU，memory，block的profile：
* -cpuprofile=$FILE
* -memprofile=$FILE, -memprofilerate=N 设置profile rate为1/N
* -blockprofile=$FILE
使用以上三个flag中的任意一个都会产生测试二进制文件 xxx.test。
生成的profile文件可以用pprof来分析。

问题：blockprofile是啥？profile rate 是啥？


## 编译优化

Go的编译器分为前端和后端。逃逸分析、内联属于前端处理，此时代码仍处在 AST 形式。后端是SSA编译器，在这一块做的优化包括对 dead code，bounds check，nil check的消除。

### 逃逸分析（Escape Analysis）

goroutine的栈用来存储局部变量。对于栈上的变量不需要做垃圾收集（GC），因为它们会在函数返回时自动被收集。所以在栈上分配内存可以提高程序效率。
在C/C++中，需要程序员自己决定选择在堆还是在栈上分配内存，如果选择有误会带来内存方面的bug。
在Go中，这部分工作由编译器完成的。如果一个值的寿命超出了函数调用的生命周期，那么编译器会自动将该值移动到堆中，这叫做**逃逸**到堆。
```go
type Foo struct {
	a, b, c, d int
}

func NewFoo() *Foo {
	return &Foo{a: 3, b: 1, c: 4, d: 7}
}
```
这段程序中，`NewFoo`函数中分配的`Foo`变量就会逃逸到堆中，因为它是作为函数的返回值，在函数调用结束后还可能会被用到。

但是编译器也可以反过来做：将本该分配在堆上的变量移动到栈上。例如：
```go
func Sum() int {
	const count = 100
	numbers := make([]int, count)
	for i := range numbers {
		numbers[i] = i + 1
	}

	var sum int
	for _, i := range numbers {
		sum += i
	}
	return sum
}

func main() {
	answer := Sum()
	fmt.Println(answer)
}
```
这段程序中，编译器会把`numbers`切片存储在栈上，因为这个变量只在`Sum`函数中被使用。这样就免去了对`numbers`变量的GC了。

口说无凭，我们可以证明这一点：使用 `-m` 打印逃逸分析结果。
`-m`表示 `print optimization decisions`。更多flag可以通过`go tool compile -h`查看。
```shell
go build -gcflags="-m" sum.go
# command-line-arguments
./sum.go:25:13: inlining call to fmt.Println
./sum.go:10:17: make([]int, count) does not escape
./sum.go:25:17: Sum() escapes to heap
./sum.go:25:13: []interface {} literal does not escape
<autogenerated>:1: .this does not escape
```
从中可看出`numbers`切片没有逃逸。


练习：
（1）Does this optimisation hold true for all values of `count`?
不是，当count较大，比如为10000时，切片会逃逸到堆上。我推测这是因为栈的空间有限，不能容纳很大的变量。

（2）Does this optimisation hold true if `count` is a variable, not a constant?
不是，把`const count = 100`改成`var count = 100`，其他代码不变，发现切片会逃逸到堆上。我推测这是因为`count`是变量时，编译器无法确定其大小，保险起见就把切片分配到堆上。

（3）Does this optimisation hold true if `count` is a parameter to `Sum`?
不是，当`count`是`Sum`函数的参数时，切片会逃逸到堆上。 推测原因同（2），编译器无法确定切片大小。

通过基准测试可做进一步验证：
```go
var result int

func BenchmarkSum(b *testing.B) {
	b.ReportAllocs()
	var r int
	for i := 0; i < b.N; i++ {
		r = Sum()
	}
	result = r
}
```
当`count`是常量时，测试结果表明没有堆内存分配：
```
goos: darwin
goarch: amd64
BenchmarkSum-12    	12470510	        88.1 ns/op	       0 B/op	       0 allocs/op
```
当`count`是变量时，测试结果表明有堆内存分配：
```
goos: darwin
goarch: amd64
BenchmarkSum-12    	 6184479	       182 ns/op	     896 B/op	       1 allocs/op
```



### 内联（Inlining）
